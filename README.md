# Notes on <img src="data:image/png;base64,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" width="30"> classes :neckbeard:

## Class Creation

- Classes are building blocks of software applications.
- A class encapsulates data (stored in fields) and behaviour (defined by methods).

```csharp
public class Customer
{
 // Field
 public string Name;
 // Method
 public void Promote()
 {
 }
}
```

- An object is an instance of a class. We can create an object using the new operator.

```csharp
Customer customer = new Customer();
// Or
var customer = new Customer();
```

## Constructors

- A constructor is a method that is called when an instance of a class is created.
- We use constructors to put an object in an early state.
- As a best practice, define a constructor only when an object “needs” to be initialised or it won’t be able to do its job.
- Constructors do not have a return type, not even void, and they should have the exact same name as the class.
- A quick way to create a constructor: type ctor and press tab. This is a code snippet.
- Constructors can be overloaded. Overloading means creating a method with the same name and different signatures.
- Signature of a method consists of the number, type and order of its parameters.
- We can pass control from one constructor to the other by using the **this** keyword.

```csharp
public class Customer
{
 public int Id;
 public string Name;
 public List<Order> Orders;

 // Default or parameterless constructor
 public Customer()
 {
 // Orders has to be initialized here, otherwise it
 // will be a null reference. As a best practice,
 // anytime your class contains a list, always
 // initialize the list.
 Orders = new List<Order>();
 }
 public Customer(int id)
 : this() // Calls the default constructor
 {
 this.Id = id;
 }
}
```

## Methods

- Signature of a method consists of the number, type and order of its parameters.
- Overloading a method means having a method with the same name but with different signatures. This makes it easier for the callers of the method to choose the more suitable signature depending on the type of data they have to pass to the method.

```csharp
public class Point
{
 public void Move(int x, int y) {}

 // The Move method overloaded here
 public void Move(Point newLocation) {}
}
```

- We can use the params modifier to give a method the ability to receive varying number of parameters.

```csharp
public class Calculator
{
 public int Add(params int[] numbers) {}
}
…
var result = calculator.Add(1, 2, 3, 4);
```

- By default, when we pass a value type (eg int, char, bool) to a method, a copy of that variable is sent to the method. So changes applied to that variable in the method will not be visible upon return from the method. This can be modified using the ref modifier. When we use the ref modifier, a reference to the original variable will be sent to the target method.
- **The ref modifier is not commonly used / recommended in C#**

```csharp
public void Weirdo(ref int a)
{
 a += 2;
}
…
var a = 1;
Weirdo(ref a);
// Here a will be 3.
```

- The out modifier can be used to return multiple values from a method. Any parameter declared with the out modifier is expected to receive a value at the end of the method.
- **Don't use this**

```csharp
public void Weirdo(out int a)
{
 a = 1;
}
…
int a;
Weirdo(out a);
```

## Fields

- A field can be initialized in two ways: In a constructor, or directly upon declaration. The benefit of initialising a field during declaration is that if your class has one or more constructors, you’ll make sure that the field will always be initialised irrespective of which constructor is going to be called. 

```csharp
public class Customer
4
{
 public List<Order> Orders = new List<Order>();
}
```

- We use the readonly modifier to improve the robustness of our code. When a field is declared with readonly, it needs to be initialized either during declaration or in a constructor. The value cannot be changed. This prevents you from accidentally overwriting the value of a field, which can result in an unexpected state. As an example, think of the Orders in the above example. If we accidentally re-initialize this field somewhere else in the class, all the Order objects stored in the list will be lost. So we should declare it as readonly:

```csharp
public class Customer
{
 public readonly List<Order> Orders = new List<Order>();
}
```

## Access Modifiers

- In C# we have 5 access modifiers: **public, private, protected, internal** and **protected internal**.
- A class member declared with public is accessible everywhere.
- A class member declared with private is accessible only from inside the class.
- We use access modifiers to hide the implementation details of a class. So anything that is about “how” a class does its job should be declared as private. This way, we make sure other parts of the code will not touch the implementation detail of a class. And as a result we improve the robustness of our code. If change the implementation of a class, we only need to make changes inside the class. No other parts of the code will need to be changed.

## Properties

- A property is a kind of class member that is used for providing access to fields of a class.
- As a best practice, we must declare fields as private and create public properties to provide access to them.
- A property encapsulates a get and a set method:

```csharp
public class Customer
{
 private string _name;
 public string Name
 {
 get { return _name; }
 set { _name = value; }
 }
}
```

- Inside the get/set methods we can have some logic.
- If you don’t need to write any specific logic in the get or set method, it’s more efficient to create an auto-implemented property. An auto-implemented property encapsulates a private field behind the scene. So you don’t need to manually create one. The compiler creates one for you:

```csharp
public class Customer
{
 public string Name { get; set; }
}
```

## Indexers
- Indexer is a special kind of property that allows accessing elements of a list by an index.
- If a class has the semantics of a list, or collection, we can define an indexer property for it. This way it’s easier to get or set items in the collection. 

```csharp
public class HttpCookie
{
 public string this[string key]
6
 {
 get {}
 set {}
 }
}
```


## Upcasting and Downcasting

- Upcasting: conversion from a derived class to a base class
- Downcasting: conversion from a base class to a derived class
- All objects can be implicitly converted to a base class reference. 

```csharp
// Upcasting
Shape shape = circle; 
```

- Downcasting requires a cast.

```csharp
// Downcasting
Circle circle = (Circle)shape;
```

- - Casting can throw an exception if the conversion is not successful. We can use the as keyword to prevent this. If conversion is not successful, null is returned. 

```csharp
Circle circle = shape as Circle;
if (circle != null) …
```

- We can also use the is keyword:

```csharp
if (shape is Circle)
{
 var circle = (Circle) shape;
}
```

## Boxing and Unboxing

- C# types are divided into two categories: value types and reference types.
- Value types (eg int, char, bool, all primitive types and struct) are stored in the stack. They have a short life time and as soon as they go out of scope are removed from memory.
- Reference types (eg all classes) are stored in the heap.
- Every object can be implicitly cast to a base class reference.
- The object class is the parent of all classes in .NET Framework.
- So a value type instance (eg int) can be implicitly cast to an object reference.
- Boxing happens when a value type instance is converted to an object reference.
- Unboxing is the opposite: when an object reference is converted to a value type.
- Both boxing and unboxing come with a performance penalty. This is not noticeable when dealing with small number of objects. But if you’re dealing with several thousands or tens of thousands of objects, it’s better to avoid it. 

```csharp
// Boxing
object obj = 1; 
```

```csharp
// Unboxing
int i = (int)obj;
```

## Access Modifiers

- Your classes should be like a black box. They should have limited visibility from the outside. The implementation, the detail, should be hidden. We use access modifiers (mostly private) to achieve this. This is referred to as Information Hiding (and sometimes Encapsulation) in object-oriented programming.
- **Public:** A member declared as public is accessible everywhere.
- **Private:** A member declared as private is accessible only from the class.
- **Protected:** A member declared as protected is accessibly only from the class and its derived classes. Protected breaks encapsulation (because the implementation details of a class will leak into its derived classes) and is better to be avoided.
- **Internal:** A member declared as internal is accessibly only from the same assembly.
- **Protected Internal:** A member declared as protected internal is accessible only from the same assembly or any derived classes. (Sounds weird? Forget it! It’s not really used.)

## Constructors and Inheritance

- Constructors are not inherited and need to explicitly defined in derived class.
- When creating an object of a type that is part of an inheritance hierarchy, base class constructors are always executed first.
- We can use the base keyword to pass control to a base class constructor.

```csharp
public class Car : Vehicle
{
  public Car(string registration) : base(registration)
  {
  }
}
```

## Method Overriding

- Method overriding means changing the implementation of an inherited method.
- If a declare a method as virtual in the base class, we can override it in a derived class.

```csharp
public class Shape
{
 public virtual Draw()
 {
 // Default implementation for all derived classes
 }
}
public class Circle : Shape
{
 public override Draw()
 {
 // Changed implementation
 }
}
```


## Sealed Classes and Members

- If applied to a class, prevents derivation from that class.
- If applied to a method, prevents overriding of that method in a derived class.
- The string class is declared as sealed, and that’s why we cannot inherit from it.

```csharp
public sealed class String
{
}
```

## Abstract Classes
- Abstract modifier states that a class or a member misses implementation. We use
abstract members when it doesn’t make sense to implement them in a base class. For
example, the concept of drawing a shape is too abstract. We don’t know how to draw
a shape. This needs to be implemented in the derived classes.
- When a class member is declared as abstract, that class needs to be declared as
abstract as well. That means that class is not complete.
- In a derived class, we need to override all abstract members of the base class,
otherwise that derived class is going to be abstract too.
- Abstract classes cannot be instantiated.

```csharp
public abstract class Shape
{
 // This method doesn’t have a body.
 public abstract Draw();
}
public class Circle : Shape
{
 public override Draw()
 {
 // Changed implementation
 }
}
```

## Interfaces 

- An interface is a language construct that is similar to a class (in terms of syntax) but is
fundamentally different.
- An interface is simply a declaration of the capabilities (or services) that a class should
provide. 

```csharp
public interface ITaxCalculator
{
 int Calculate();
}
```

- This interface states a class that wants to play the role of a tax calculator, should provide a method called Calculate() that takes no parameters and returns an int. The implementation of this class might look like this:

```csharp
public class TaxCalculator : ITaxCalculator
{
 public void Calculate() { … }
}
```

- So an interface is purely a declaration. Members of an interface do not have
implementation.
- An interface can only declare methods and properties, but not fields (because fields are about implementation detail).
- Members of an interface do not have access modifiers.
- Interfaces help building loosely coupled applications. We reduce the coupling between two classes by putting an interface between them. This way, if one of these classes changes, it will have no impact on the class that is dependent on that (as long as the interface is kept the same).

## Interfaces and Testability

- Unit testing is part of the automated practice which helps improve the quality of our code. With automated testing, we write code to test our own code. This helps catching bugs early on as we change the code.
- In order to unit test a class, we need to isolate it. This means: we need to assume that every other class in our application is working properly and see if the class under test is working as expected.
- A class that has tight dependencies to other classes cannot be isolated.
- To solve this problem, we use an interface. Here is an example:

```csharp
public class OrderProcessor
{
 private IShippingCalculator _calculator;

 public Customer(IShippingCalculator calculator)
 {
 _calculator = calculator;
 }
 …
}
```

- So here, OrderProcessor is not dependent on the ShippingCalculator class. It’s only dependent on an interface (IShippingCalculator). If we change the code inside the ShippingCalculator (eg add a new method or change the method implementations) it will have no impact on OrderProcessor (as long as the interface is kept the same).

## Interfaces and Extensibility

- We can use interfaces to change our application’s behaviour by “extending” its code (rather than changing the existing code).
- If a class is dependent on an interface, we can supply a different implementation of that interface at runtime. This way, the behaviour of the application changes without any impact on that class.
- For example, let’s assume our DbMigrator class is dependent on an ILogger
interface. At runtime, we can supply a ConsoleLogger to log the messages on the
console. Later, we may decide to log the messages in a file (or a database). We can
simply create a new class that implements the ILogger interface and inject it into
DbMigrator.

## Interfaces and Inheritance

- One of the common misconceptions about interfaces is that they are used to
implement multiple inheritance in C#. This is fundamentally wrong, yet many books
and videos make such a false claim.
- With inheritance, we write code once and re-use it without the need to type all that code again.
- With interfaces, we simply declare the members the implementing class should
contain. Then we need to type all that declaration along with the actual implementation in that class. So, code is not inherited, even the declaration of the members!
